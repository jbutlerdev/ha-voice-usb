substitutions:
  # Phases of the Voice Assistant
  # The voice assistant is ready to be triggered by a wake word
  voice_assist_idle_phase_id: '1'
  # The voice assistant is waiting for a voice command (after being triggered by the wake word)
  voice_assist_waiting_for_command_phase_id: '2'
  # The voice assistant is listening for a voice command
  voice_assist_listening_for_command_phase_id: '3'
  # The voice assistant is currently processing the command
  voice_assist_thinking_phase_id: '4'
  # The voice assistant is replying to the command
  voice_assist_replying_phase_id: '5'
  # The voice assistant is not ready
  voice_assist_not_ready_phase_id: '10'
  # The voice assistant encountered an error
  voice_assist_error_phase_id: '11'
  # Change this to true in case you ahve a hidden SSID at home.
  hidden_ssid: "false"

esphome:
  name: home-assistant-voice-usb
  friendly_name: Home Assistant Voice USB
  name_add_mac_suffix: true
  min_version: 2025.5.1
  on_boot:
    - priority: 375
      then:
        # Run the script to refresh the LED status
        - script.execute: control_leds
        - delay: 1s
        - switch.turn_on: internal_speaker_amp
        # USB mode - shorter initialization time since no WiFi/HA connection needed
        - delay: 5s
        - if:
            condition:
              lambda: return id(init_in_progress);
            then:
              - lambda: id(init_in_progress) = false;
              - script.execute: control_leds
        # Start wake word detection in USB mode (no voice assistant to auto-start it)
        - delay: 2s
        - micro_wake_word.start:
        - logger.log: "Wake word detection started in USB mode"
        # USB communication component will handle all communication
    - priority: 200  # After speaker setup
      then:
        - lambda: |-
            // Set speaker reference to use factory firmware's announcement audio path
            id(usb_comm_component).set_speaker(id(announcement_resampling_speaker));
            // Set microphone reference for real audio capture
            id(usb_comm_component).set_microphone(id(i2s_mics));
            ESP_LOGD("usb_config", "USB communication configured with speaker and microphone references");

esp32:
  board: esp32-s3-devkitc-1
  cpu_frequency: 240MHz
  variant: esp32s3
  flash_size: 16MB
  framework:
    type: esp-idf
    version: recommended
    sdkconfig_options:
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"
      CONFIG_ESP32S3_INSTRUCTION_CACHE_32KB: "y"

      # Moves instructions and read only data from flash into PSRAM on boot.
      # Both enabled allows instructions to execute while a flash operation is in progress without needing to be placed in IRAM.
      # Considerably speeds up mWW at the cost of using more PSRAM.
      CONFIG_SPIRAM_RODATA: "y"
      CONFIG_SPIRAM_FETCH_INSTRUCTIONS: "y"

      CONFIG_BT_ALLOCATION_FROM_SPIRAM_FIRST: "y"
      CONFIG_BT_BLE_DYNAMIC_ENV_MEMORY: "y"

      CONFIG_MBEDTLS_EXTERNAL_MEM_ALLOC: "y"
      CONFIG_MBEDTLS_SSL_PROTO_TLS1_3: "y"  # TLS1.3 support isn't enabled by default in IDF 5.1.5
      
      # CRITICAL: Disable ESP32 system logging on UART0 completely
      CONFIG_ESP_CONSOLE_UART_NONE: "y"
      CONFIG_ESP_CONSOLE_NONE: "y"
      CONFIG_LOG_DEFAULT_LEVEL_NONE: "y"
      CONFIG_BOOTLOADER_LOG_LEVEL_NONE: "y"

# NO WIFI - USB COMMUNICATION ONLY
# NO NETWORK - USB COMMUNICATION ONLY

logger:
  # Disable UART logging to avoid interference - we'll use USB Serial/JTAG for communication
  baud_rate: 0
  level: DEBUG  # Reduced verbosity 
  logs:
    sensor: ERROR
    usb_communication: DEBUG  # Reduced verbosity for now
    uart: ERROR


# USB Serial Communication for Home Assistant Voice hardware
# The hardware uses USB Serial/JTAG interface via USB-C port

# NO API - USB COMMUNICATION ONLY (voice_assistant requires network connectivity)
# NO OTA - USB FLASHING ONLY

i2c:
  - id: internal_i2c
    sda: GPIO5
    scl: GPIO6
    frequency: 400kHz

psram:
  mode: octal
  speed: 80MHz

globals:
  # Global functions for microphone data injection
  - id: audio_injection_enabled
    type: bool
    initial_value: 'true'
  # Global index for our LEDs. So that switching between different animation does not lead to unwanted effects.
  - id: global_led_animation_index
    type: int
    restore_value: no
    initial_value: '0'
  # Global initialization variable. Initialized to true and set to false once everything is connected. Only used to have a smooth "plugging" experience
  - id: init_in_progress
    type: bool
    restore_value: no
    initial_value: 'true'
  # NO IMPROV BLE IN USB-ONLY MODE
  # Global variable tracking the phase of the voice assistant (defined above). Initialized to not_ready
  - id: voice_assistant_phase
    type: int
    restore_value: no
    initial_value: ${voice_assist_not_ready_phase_id}
  # Global variable tracking if the dial was recently touched.
  - id: dial_touched
    type: bool
    restore_value: no
    initial_value: 'false'
  # Global variable tracking if the LED color was recently changed.
  - id: color_changed
    type: bool
    restore_value: no
    initial_value: 'false'
  # Global variable tracking if the jack has been plugged touched.
  - id: jack_plugged_recently
    type: bool
    restore_value: no
    initial_value: 'false'
  # Global variable tracking if the jack has been unplugged touched.
  - id: jack_unplugged_recently
    type: bool
    restore_value: no
    initial_value: 'false'
  # NO TIMER VARIABLES IN USB-ONLY MODE (REQUIRES HOME ASSISTANT)
  # Timer functionality handled by Mac app
  # Keep is_timer_active for LED compatibility but always false in USB mode
  - id: is_timer_active
    type: bool
    restore_value: false
    initial_value: 'false'
  # USB connection status for communication with the Swift app
  - id: usb_connected
    type: bool
    restore_value: no
    initial_value: 'false'
  # Global variable storing if a factory reset was requested. If it is set to true, the device will factory reset once the center button is released
  - id: factory_reset_requested
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: usb_last_heartbeat
    type: unsigned long
    restore_value: no
    initial_value: '0'
  # Real voice detection variables
  - id: voice_detection_active
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: silence_samples
    type: int
    restore_value: no
    initial_value: '0'
  - id: voice_detected
    type: bool
    restore_value: no
    initial_value: 'false'

switch:
  # This is the master mute switch. It is exposed to Home Assistant. The user can only turn it on and off if the hardware switch is off. (The hardware switch overrides the software one)
  - platform: template
    id: master_mute_switch
    restore_mode: RESTORE_DEFAULT_OFF
    icon: "mdi:microphone-off"
    name: Mute
    entity_category: config
    lambda: |-
      // Muted either if the hardware mute switch is on or the microphone's software mute switch is enabled
      if (id(hardware_mute_switch).state || id(i2s_mics).get_mute_state()) {
        return true;
      } else {
        return false;
      }
    turn_on_action:
      - if:
          condition:
            binary_sensor.is_off: hardware_mute_switch
          then:
            - microphone.mute:
    turn_off_action:
      - if:
          condition:
            binary_sensor.is_off: hardware_mute_switch
          then:
            - microphone.unmute:
    on_turn_on:
      - script.execute: control_leds
    on_turn_off:
      - script.execute: control_leds
  # Wake Word Sound Switch.
  - platform: template
    id: wake_sound
    name: Wake sound
    icon: "mdi:bullhorn"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  # Internal switch to track when a timer is ringing on the device.
  - platform: template
    id: timer_ringing
    optimistic: true
    internal: true
    restore_mode: ALWAYS_OFF
    on_turn_off:
      # Disable stop wake word
      - micro_wake_word.disable_model: stop
      - script.execute: disable_repeat
      # Stop any current annoucement (ie: stop the timer ring mid playback)
      - if:
          condition:
            media_player.is_announcing:
          then:
            media_player.stop:
              announcement: true
      # Set back ducking ratio to zero
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 0
          duration: 1.0s
      # Refresh the LED ring
      - script.execute: control_leds
    on_turn_on:
      # Duck audio
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 20
          duration: 0.0s
      # Enable stop wake word
      - micro_wake_word.enable_model: stop
      # Ring timer
      - script.execute: ring_timer
      # Refresh LED
      - script.execute: control_leds
      # If 15 minutes have passed and the timer is still ringing, stop it.
      - delay: 15min
      - switch.turn_off: timer_ringing
  - platform: gpio
    pin: GPIO47
    id: internal_speaker_amp
    name: "Internal speaker amp"
    entity_category: config
    restore_mode: ALWAYS_OFF
    internal: true

binary_sensor:
  # Center Button. Used for many things (See on_multi_click)
  - platform: gpio
    id: center_button
    pin:
      number: GPIO0
      inverted: true
    on_press:
      - script.execute: control_leds
    on_release:
      - script.execute: control_leds
      # If a factory reset is requested, factory reset on release
      - if:
          condition:
            lambda: return id(factory_reset_requested);
          then:
            - button.press: factory_reset_button
    on_multi_click:
      # Simple Click:
      #   - Abort "things" in order
      #     - Timer
      #     - Announcements
      #     - Voice Assistant Pipeline run
      #     - Music
      #   - Starts the voice assistant if it is not yet running and if the device is not muted.
      - timing:
          - ON for at most 1s
          - OFF for at least 0.25s
        then:
          - if:
              condition:
                lambda: return !id(init_in_progress) && !id(color_changed);
              then:
                - if:
                    condition:
                      switch.is_on: timer_ringing
                    then:
                      - switch.turn_off: timer_ringing
                    else:
                      - if:
                          condition:
                            media_player.is_announcing:
                          then:
                            media_player.stop:
                              announcement: true
                          else:
                            - if:
                                condition:
                                  media_player.is_playing:
                                then:
                                  - media_player.pause:
                                else:
                                  - if:
                                      condition:
                                        and:
                                          - switch.is_off: master_mute_switch
                                          # Check if already in listening mode - if so, stop listening
                                          - lambda: return id(voice_assistant_phase) != ${voice_assist_waiting_for_command_phase_id} && id(voice_assistant_phase) != ${voice_assist_listening_for_command_phase_id};
                                      then:
                                        - script.execute:
                                            id: play_sound
                                            priority: true
                                            sound_file: !lambda return id(center_button_press_sound);
                                        - delay: 300ms
                                        # Set voice assistant phase for USB mode LED control
                                        - lambda: |-
                                            ESP_LOGD("center_button", "Center button pressed, setting waiting for command phase");
                                            ESP_LOGD("center_button", "Previous phase: %d", id(voice_assistant_phase));
                                            id(voice_assistant_phase) = ${voice_assist_waiting_for_command_phase_id};
                                            ESP_LOGD("center_button", "New phase: %d", id(voice_assistant_phase));
                                            id(usb_comm_component).update_voice_phase(${voice_assist_waiting_for_command_phase_id});
                                            // Send button press event to USB app
                                            printf("{\"type\":\"button_pressed\",\"timestamp\":%lu}\n", millis());
                                            fflush(stdout);
                                        - script.execute: control_leds
                                        # Start audio recording and voice detection
                                        - script.execute: start_audio_recording
                                        - script.execute: start_voice_detection
                                      else:
                                        # Device is already listening - stop listening and return to idle
                                        - script.execute:
                                            id: play_sound
                                            priority: true
                                            sound_file: !lambda return id(center_button_press_sound);
                                        - lambda: |-
                                            ESP_LOGD("center_button", "Center button pressed while listening - returning to idle");
                                            ESP_LOGD("center_button", "Previous phase: %d", id(voice_assistant_phase));
                                            id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
                                            id(usb_comm_component).update_voice_phase(${voice_assist_idle_phase_id});
                                            // Send stop listening event to USB app
                                            printf("{\"type\":\"stop_listening\",\"timestamp\":%lu}\n", millis());
                                            fflush(stdout);
                                        # Stop audio recording and voice detection
                                        - script.execute: stop_audio_recording
                                        - script.execute: stop_voice_detection
                                        - script.execute: control_leds
      # Double Click
      #  . Exposed as an event entity. To be used in automations inside Home Assistant
      - timing:
          - ON for at most 1s
          - OFF for at most 0.25s
          - ON for at most 1s
          - OFF for at least 0.25s
        then:
          - if:
              condition:
                lambda: return !id(init_in_progress) && !id(color_changed);
              then:
                - script.execute:
                    id: play_sound
                    priority: false
                    sound_file: !lambda return id(center_button_double_press_sound);
                - event.trigger:
                    id: button_press_event
                    event_type: "double_press"
      # Triple Click
      #  . Exposed as an event entity. To be used in automations inside Home Assistant
      - timing:
          - ON for at most 1s
          - OFF for at most 0.25s
          - ON for at most 1s
          - OFF for at most 0.25s
          - ON for at most 1s
          - OFF for at least 0.25s
        then:
          - if:
              condition:
                lambda: return !id(init_in_progress) && !id(color_changed);
              then:
                - script.execute:
                    id: play_sound
                    priority: false
                    sound_file: !lambda return id(center_button_triple_press_sound);
                - event.trigger:
                    id: button_press_event
                    event_type: "triple_press"
      # Long Press
      #  . Exposed as an event entity. To be used in automations inside Home Assistant
      - timing:
          - ON for at least 1s
        then:
          - if:
              condition:
                lambda: return !id(init_in_progress) && !id(color_changed);
              then:
                - script.execute:
                    id: play_sound
                    priority: false
                    sound_file: !lambda return id(center_button_long_press_sound);
                - light.turn_off: voice_assistant_leds
                - event.trigger:
                    id: button_press_event
                    event_type: "long_press"
      # Very important do not remove. Trust me :D
      - timing:
          # H ....
          - ON for at most 0.2s
          - OFF for 0s to 2s
          - ON for at most 0.2s
          - OFF for 0s to 2s
          - ON for at most 0.2s
          - OFF for 0s to 2s
          - ON for at most 0.2s
          - OFF for 0.5s to 2s
          # A ._
          - ON for at most 0.2s
          - OFF for 0s to 2s
          - ON for 0.2s to 2s
        then:
          - if:
              condition:
                lambda: return !id(init_in_progress);
              then:
                - light.turn_on:
                    brightness: 100%
                    id: voice_assistant_leds
                    effect: "Tick"
                - script.execute:
                    id: play_sound
                    priority: true
                    sound_file: !lambda return id(easter_egg_tick_sound);
                - delay: 4s
                - light.turn_off: voice_assistant_leds
                - script.execute:
                    id: play_sound
                    priority: true
                    sound_file: !lambda return id(easter_egg_tada_sound);
                - light.turn_on:
                    brightness: 100%
                    id: voice_assistant_leds
                    effect: "Rainbow"
                - event.trigger:
                    id: button_press_event
                    event_type: "easter_egg_press"
      # Factory Reset Warning
      #  . Audible and Visible warning.
      - timing:
          - ON for at least 10s
        then:
          - if:
              condition:
                lambda: return !id(dial_touched);
              then:
                - light.turn_on:
                    brightness: 100%
                    id: voice_assistant_leds
                    effect: "Factory Reset Coming Up"
                - script.execute:
                    id: play_sound
                    priority: true
                    sound_file: !lambda return id(factory_reset_initiated_sound);
                - wait_until:
                    binary_sensor.is_off: center_button
                - if:
                    condition:
                      lambda: return !id(factory_reset_requested);
                    then:
                      - light.turn_off: voice_assistant_leds
                      - script.execute:
                          id: play_sound
                          priority: true
                          sound_file: !lambda return id(factory_reset_cancelled_sound);
      # Factory Reset Confirmed.
      #  . Audible warning to prompt user to release the button
      #  . Set factory_reset_requested to true
      - timing:
          - ON for at least 22s
        then:
          - if:
              condition:
                lambda: return !id(dial_touched);
              then:
                - script.execute:
                    id: play_sound
                    priority: true
                    sound_file: !lambda return id(factory_reset_confirmed_sound);
                - light.turn_on:
                    brightness: 100%
                    red: 100%
                    green: 0%
                    blue: 0%
                    id: voice_assistant_leds
                    effect: "none"
                - lambda: id(factory_reset_requested) = true;

  # Hardware mute switch (Side of the device)
  - platform: gpio
    id: hardware_mute_switch
    internal: true
    pin: GPIO3
    on_press:
      # Play mute on sound only if software mute isn't enabled
      - if:
          condition:
            - switch.is_off: master_mute_switch
          then:
            - script.execute:
                id: play_sound
                priority: false
                sound_file: !lambda return id(mute_switch_on_sound);
    on_release:
      - script.execute:
          id: play_sound
          priority: false
          sound_file: !lambda return id(mute_switch_off_sound);
      - microphone.unmute:
  # Audio Jack Plugged sensor
  - platform: gpio
    id: jack_plugged
    # Debouncing it a bit because it can be activated back and forth as you plug the audio jack
    filters:
      - delayed_on: 200ms
      - delayed_off: 200ms
    pin:
      number: GPIO17
    # When the jack is plugged in:
    #  - LED animation
    #  - Sound played
    on_press:
      - lambda: id(jack_plugged_recently) = true;
      - script.execute: control_leds
      - delay: 200ms
      - script.execute:
          id: play_sound
          priority: false
          sound_file: !lambda return id(jack_connected_sound);
      - delay: 800ms
      - lambda: id(jack_plugged_recently) = false;
      - script.execute: control_leds
    # When the jack is unplugged:
    #  - LED animation
    #  - Sound played
    on_release:
      - lambda: id(jack_unplugged_recently) = true;
      - script.execute: control_leds
      - delay: 200ms
      - script.execute:
          id: play_sound
          priority: false
          sound_file: !lambda return id(jack_disconnected_sound);
      - delay: 800ms
      - lambda: id(jack_unplugged_recently) = false;
      - script.execute: control_leds

light:
  # Hardware LED ring. Not used because remapping needed
  - platform: esp32_rmt_led_strip
    id: leds_internal
    pin: GPIO21
    chipset: WS2812
    max_refresh_rate: 15ms
    num_leds: 12
    rgb_order: GRB
    rmt_symbols: 192
    default_transition_length: 0ms
    power_supply: led_power

  # Voice Assistant LED ring. Remapping of the internal LED.
  # This light is not exposed. The device controls it
  - platform: partition
    id: voice_assistant_leds
    internal: true
    default_transition_length: 0ms
    segments:
      - id: leds_internal
        from: 7
        to: 11
      - id: leds_internal
        from: 0
        to: 6
    effects:
      - addressable_lambda:
          name: "Waiting for Command"
          update_interval: 100ms
          lambda: |-
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 12; i++) {
              if (i == id(global_led_animation_index) % 12) {
                it[i] = color;
              } else if (i == (id(global_led_animation_index) + 11) % 12) {
                it[i] = color * 192;
              } else if (i == (id(global_led_animation_index) + 10) % 12) {
                it[i] = color * 128;
              } else if (i == (id(global_led_animation_index) + 6) % 12) {
                it[i] = color;
              } else if (i == (id(global_led_animation_index) + 5) % 12) {
                it[i] = color * 192;
              } else if (i == (id(global_led_animation_index) + 4) % 12) {
                it[i] = color * 128;
              } else {
                it[i] = Color::BLACK;
              }
            }
            id(global_led_animation_index) = (id(global_led_animation_index) + 1) % 12;
      - addressable_lambda:
          name: "Listening For Command"
          update_interval: 50ms
          lambda: |-
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 12; i++) {
              if (i == id(global_led_animation_index) % 12) {
                it[i] = color;
              } else if (i == (id(global_led_animation_index) + 11) % 12) {
                it[i] = color * 192;
              } else if (i == (id(global_led_animation_index) + 10) % 12) {
                it[i] = color * 128;
              } else if (i == (id(global_led_animation_index) + 6) % 12) {
                it[i] = color;
              } else if (i == (id(global_led_animation_index) + 5) % 12) {
                it[i] = color * 192;
              } else if (i == (id(global_led_animation_index) + 4) % 12) {
                it[i] = color * 128;
              } else {
                it[i] = Color::BLACK;
              }
            }
            id(global_led_animation_index) = (id(global_led_animation_index) + 1) % 12;
      - addressable_lambda:
          name: "Thinking"
          update_interval: 10ms
          lambda: |-
            static uint8_t brightness_step = 0;
            static bool brightness_decreasing = true;
            static uint8_t brightness_step_number = 10;
            if (initial_run) {
              brightness_step = 0;
              brightness_decreasing = true;
            }
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 12; i++) {
              if (i == id(global_led_animation_index) % 12) {
                it[i] = color * uint8_t(255/brightness_step_number*(brightness_step_number-brightness_step));
              } else if (i == (id(global_led_animation_index) + 6) % 12) {
                it[i] = color * uint8_t(255/brightness_step_number*(brightness_step_number-brightness_step));
              } else {
                it[i] = Color::BLACK;
              }
            }
            if (brightness_decreasing) {
              brightness_step++;
            } else {
              brightness_step--;
            }
            if (brightness_step == 0 || brightness_step == brightness_step_number) {
              brightness_decreasing = !brightness_decreasing;
            }
      - addressable_lambda:
          name: "Replying"
          update_interval: 50ms
          lambda: |-
            id(global_led_animation_index) = (12 + id(global_led_animation_index) - 1) % 12;
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 12; i++) {
              if (i == (id(global_led_animation_index)) % 12) {
                it[i] = color;
              } else if (i == ( id(global_led_animation_index) + 1) % 12) {
                it[i] = color * 192;
              } else if (i == ( id(global_led_animation_index) + 2) % 12) {
                it[i] = color * 128;
              } else if (i == ( id(global_led_animation_index) + 6) % 12) {
                it[i] = color;
              } else if (i == ( id(global_led_animation_index) + 7) % 12) {
                it[i] = color * 192;
              } else if (i == ( id(global_led_animation_index) + 8) % 12) {
                it[i] = color * 128;
              } else {
                it[i] = Color::BLACK;
              }
            }
      - addressable_lambda:
          name: "Muted or Silent"
          update_interval: 16ms
          lambda: |-
            static int8_t index = 0;
            Color muted_color(255, 0, 0);
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 12; i++) {
              if ( light_color.get_state() ) {
                it[i] = color;
              } else {
                it[i] = Color::BLACK;
              }
            }
            if ( id(master_mute_switch).state ) {
              it[2] = Color::BLACK;
              it[3] = muted_color;
              it[4] = Color::BLACK;
              it[8] = Color::BLACK;
              it[9] = muted_color;
              it[10] = Color::BLACK;
            }
            if ( id(external_media_player).volume == 0.0f || id(external_media_player).is_muted() ) {
              it[5] = Color::BLACK;
              it[6] = muted_color;
              it[7] = Color::BLACK;
            }
      - addressable_lambda:
          name: "Volume Display"
          update_interval: 50ms
          lambda: |-
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            Color silenced_color(255, 0, 0);
            auto volume_ratio = 12.0f * id(external_media_player).volume;
            for (int i = 0; i < 12; i++) {
              if (i <= volume_ratio) {
                it[(6+i)%12] = color * min( 255.0f * (volume_ratio - i) , 255.0f ) ;
              } else {
                it[(6+i)%12] = Color::BLACK;
              }
            }
            if (id(external_media_player).volume == 0.0f) {
              it[6] = silenced_color;
            }
      - addressable_lambda:
          name: "Center Button Touched"
          update_interval: 16ms
          lambda: |-
            if (initial_run) {
              // set voice_assistant_leds light to colors based on led_ring
              auto led_ring_cv = id(led_ring).current_values;
              auto va_leds_call = id(voice_assistant_leds).make_call();
              va_leds_call.from_light_color_values(led_ring_cv);
              va_leds_call.set_brightness( min ( max( id(led_ring).current_values.get_brightness() , 0.2f ) + 0.1f , 1.0f ) );
              va_leds_call.set_state(true);
              va_leds_call.perform();
            }
            auto light_color = id(voice_assistant_leds).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 12; i++) {
              it[i] = color;
            }
      - addressable_twinkle:
          name: "Twinkle"
          twinkle_probability: 50%
      - addressable_lambda:
          name: "Error"
          update_interval: 10ms
          lambda: |-
            static uint8_t brightness_step = 0;
            static bool brightness_decreasing = true;
            static uint8_t brightness_step_number = 10;
            if (initial_run) {
              brightness_step = 0;
              brightness_decreasing = true;
            }
            Color error_color(255, 0, 0);
            for (int i = 0; i < 12; i++) {
              it[i] = error_color * uint8_t(255/brightness_step_number*(brightness_step_number-brightness_step));
            }
            if (brightness_decreasing) {
              brightness_step++;
            } else {
              brightness_step--;
            }
            if (brightness_step == 0 || brightness_step == brightness_step_number) {
              brightness_decreasing = !brightness_decreasing;
            }
      - addressable_lambda:
          name: "Timer Ring"
          update_interval: 10ms
          lambda: |-
            static uint8_t brightness_step = 0;
            static bool brightness_decreasing = true;
            static uint8_t brightness_step_number = 10;
            if (initial_run) {
              brightness_step = 0;
              brightness_decreasing = true;
            }
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            Color muted_color(255, 0, 0);
            for (int i = 0; i < 12; i++) {
              it[i] = color * uint8_t(255/brightness_step_number*(brightness_step_number-brightness_step));
            }
            if ( id(master_mute_switch).state ) {
              it[3] = muted_color;
              it[9] = muted_color;
            }
            if (brightness_decreasing) {
              brightness_step++;
            } else {
              brightness_step--;
            }
            if (brightness_step == 0 || brightness_step == brightness_step_number) {
              brightness_decreasing = !brightness_decreasing;
            }
      - addressable_lambda:
          name: "Timer Tick"
          update_interval: 100ms
          lambda: |-
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            Color muted_color(255, 0, 0);
            // Timer functionality moved to Mac app - show simple animation
            auto timer_ratio = 6.0f;  // Default half-circle for USB mode
            uint8_t last_led_on = static_cast<uint8_t>(ceil(timer_ratio)) - 1;
            for (int i = 0; i < 12; i++) {
              float brightness_dip = ( i == id(global_led_animation_index) % 12 && i != last_led_on ) ? 0.9f : 1.0f ;
              if (i <= timer_ratio) {
                it[i] = color * min(255.0f * brightness_dip * (timer_ratio - i) , 255.0f * brightness_dip) ;
              } else {
                it[i] = Color::BLACK;
              }
            }
            if (id(master_mute_switch).state) {
              it[2] = Color::BLACK;
              it[3] = muted_color;
              it[4] = Color::BLACK;
              it[8] = Color::BLACK;
              it[9] = muted_color;
              it[10] = Color::BLACK;
            }
            id(global_led_animation_index) = (12 + id(global_led_animation_index) - 1) % 12;
      - addressable_rainbow:
          name: "Rainbow"
          width: 12
      - addressable_lambda:
          name: "Tick"
          update_interval: 333ms
          lambda: |-
            static uint8_t index = 0;
            Color color(255, 0, 0);
            if (initial_run) {
              index = 0;
            }
            for (int i = 0; i < 12; i++) {
              if (i <= index ) {
                it[i] = Color::BLACK;
              } else {
                it[i] = color;
              }
            }
            index = (index + 1) % 12;
      - addressable_lambda:
          name: "Factory Reset Coming Up"
          update_interval: 1s
          lambda: |-
            static uint8_t index = 0;
            Color color(255, 0, 0);
            if (initial_run) {
              index = 0;
            }
            for (int i = 0; i < 12; i++) {
              if (i <= index ) {
                it[i] = color;
              } else {
                it[i] = Color::BLACK;
              }
            }
            index = (index + 1) % 12;
      - addressable_lambda:
          name: "Jack Plugged"
          update_interval: 40ms
          lambda: |-
              static uint8_t index = 0;
              if (initial_run) {
                index = 0;
              }
              auto light_color = id(led_ring).current_values;
              Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                    light_color.get_blue() * 255);
              if (index <= 6) {
                for (int i = 0; i < 12; i++) {
                  if (i == index) {
                    it[i] = color;
                  } else if (i == (12 - index) % 12) {
                    it[i] = color;
                  } else {
                    it[i] = Color::BLACK;
                  }
                }
              }
              index = (index + 1);
      - addressable_lambda:
          name: "Jack Unplugged"
          update_interval: 40ms
          lambda: |-
              static uint8_t index = 0;
              if (initial_run) {
                index = 0;
              }
              auto light_color = id(led_ring).current_values;
              Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                    light_color.get_blue() * 255);
              if (index <= 6) {
                for (int i = 0; i < 12; i++) {
                  if (i == 6 - index) {
                    it[i] = color;
                  } else if (i == (6 + index) % 12) {
                    it[i] = color;
                  } else {
                    it[i] = Color::BLACK;
                  }
                }
              }
              index = (index + 1);
      - addressable_lambda:
          name: "USB Connected"
          update_interval: 500ms
          lambda: |-
              static int blink_count = 0;
              static bool blink_state = false;
              Color usb_color(0, 255, 0);  // Green for USB connection
              
              // Blink green twice, then turn off
              if (blink_count < 4) {  // 4 updates = 2 blinks (on-off-on-off)
                for (int i = 0; i < 12; i++) {
                  it[i] = blink_state ? usb_color : Color::BLACK;
                }
                blink_state = !blink_state;
                blink_count++;
              } else {
                // After 2 blinks, turn off completely
                for (int i = 0; i < 12; i++) {
                  it[i] = Color::BLACK;
                }
              }

  # User facing LED ring. Remapping of the internal LEDs.
  # Exposed to be used by the user.
  - platform: partition
    id: led_ring
    name: LED Ring
    entity_category: config
    icon: "mdi:circle-outline"
    default_transition_length: 0ms
    restore_mode: RESTORE_DEFAULT_OFF
    initial_state:
      color_mode: rgb
      brightness: 66%
      red: 9.4%
      green: 73.3%
      blue: 94.9%
    segments:
      - id: leds_internal
        from: 7
        to: 11
      - id: leds_internal
        from: 0
        to: 6

power_supply:
  - id: led_power
    pin: GPIO45

sensor:
  # The dial. Used to control volume and Hue of the LED ring.
  - platform: rotary_encoder
    id: dial
    pin_a: GPIO16
    pin_b: GPIO18
    resolution: 2
    on_clockwise:
      - lambda: id(dial_touched) = true;
      - if:
          condition:
            binary_sensor.is_off: center_button
          then:
            - script.execute:
                id: control_volume
                increase_volume: true
          else:
            - script.execute:
                id: control_hue
                increase_hue: true
    on_anticlockwise:
      - lambda: id(dial_touched) = true;
      - if:
          condition:
            binary_sensor.is_off: center_button
          then:
            - script.execute:
                id: control_volume
                increase_volume: false
          else:
            - script.execute:
                id: control_hue
                increase_hue: false


event:
  # Event entity exposed to the user to automate on complex center button presses.
  # The simple press is not exposed as it is used to control the device itself.
  - platform: template
    id: button_press_event
    name: "Button press"
    icon: mdi:button-pointer
    device_class: button
    event_types:
      - double_press
      - triple_press
      - long_press
      - easter_egg_press

script:
  # Master script controlling the LEDs, based on different conditions : initialization in progress, wifi and api connected, USB connection and voice assistant phase.
  # For the sake of simplicity and re-usability, the script calls child scripts defined below.
  # This script will be called every time one of these conditions is changing.
  - id: control_leds
    then:
      - lambda: |
          // Timer functionality handled by Mac app in USB mode
          // id(check_if_timers_active).execute();
          // if (id(is_timer_active)){
          //   id(fetch_first_active_timer).execute();
          // }
          // Priority order: Critical states first, then voice assistant phases, then other states
          if (id(init_in_progress)) {
            id(control_leds_init_state).execute();
          } else if (id(timer_ringing).state) {
            id(control_leds_timer_ringing).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_waiting_for_command_phase_id}) {
            ESP_LOGD("led_control", "Voice assistant waiting for command - showing LED animation");
            id(control_leds_voice_assistant_waiting_for_command_phase).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_listening_for_command_phase_id}) {
            ESP_LOGD("led_control", "Voice assistant listening for command - showing LED animation");
            id(control_leds_voice_assistant_listening_for_command_phase).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_thinking_phase_id}) {
            ESP_LOGD("led_control", "Voice assistant thinking - showing LED animation");
            id(control_leds_voice_assistant_thinking_phase).execute();
          } else if (id(center_button).state) {
            id(control_leds_center_button_touched).execute();
          } else if (id(jack_plugged_recently)) {
            id(control_leds_jack_plugged_recently).execute();
          } else if (id(jack_unplugged_recently)) {
            id(control_leds_jack_unplugged_recently).execute();
          } else if (id(dial_touched)) {
            id(control_leds_dial_touched).execute();
          } else if (id(usb_connected)) {
            id(control_leds_usb_connected_state).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_replying_phase_id}) {
            id(control_leds_voice_assistant_replying_phase).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_error_phase_id}) {
            id(control_leds_voice_assistant_error_phase).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_not_ready_phase_id}) {
            id(control_leds_voice_assistant_not_ready_phase).execute();
          } else if (id(is_timer_active)) {
            id(control_leds_timer_ticking).execute();
          } else if (id(master_mute_switch).state) {
            id(control_leds_muted_or_silent).execute();
          } else if (id(external_media_player).volume == 0.0f || id(external_media_player).is_muted()) {
            id(control_leds_muted_or_silent).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_idle_phase_id}) {
            id(control_leds_voice_assistant_idle_phase).execute();
          }

  # NO IMPROV BLE IN USB-ONLY MODE

  # Script executed during initialization (USB mode)
  # Solid warm white during boot
  - id: control_leds_init_state
    then:
      - light.turn_on:
          brightness: 66%
          red: 100%
          green: 89%
          blue: 71%
          id: voice_assistant_leds
          effect: "none"

  # Script executed when USB is connected (Local Voice Assistant mode)
  # Green blinking LED to indicate USB connection
  - id: control_leds_usb_connected_state
    then:
      - light.turn_on:
          brightness: 66%
          red: 9.4%
          green: 73.3%
          blue: 94.9%
          id: voice_assistant_leds
          effect: "USB Connected"

  # NO HOME ASSISTANT CONNECTION IN USB-ONLY MODE

  # Script executed when the voice assistant is idle (waiting for a wake word)
  # Nothing (Either LED ring off or LED ring on if the user decided to turn the user facing LED ring on)
  - id: control_leds_voice_assistant_idle_phase
    then:
      - light.turn_off: voice_assistant_leds
      - if:
          condition:
            light.is_on: led_ring
          then:
            light.turn_on: led_ring

  # Script executed when the voice assistant is waiting for a command (After the wake word)
  # Slow clockwise spin of the LED ring.
  - id: control_leds_voice_assistant_waiting_for_command_phase
    then:
      - light.turn_on:
          brightness: !lambda return max( id(led_ring).current_values.get_brightness() , 0.2f );
          id: voice_assistant_leds
          effect: "Waiting for Command"

  # Script executed when the voice assistant is listening to a command
  # Fast clockwise spin of the LED ring.
  - id: control_leds_voice_assistant_listening_for_command_phase
    then:
      - light.turn_on:
          brightness: !lambda return max( id(led_ring).current_values.get_brightness() , 0.2f );
          id: voice_assistant_leds
          effect: "Listening For Command"

  # Script executed when the voice assistant is thinking to a command
  # The spin stops and the 2 LEDs that are currently on and blinking indicating the commend is being processed.
  - id: control_leds_voice_assistant_thinking_phase
    then:
      - light.turn_on:
          brightness: !lambda return max( id(led_ring).current_values.get_brightness() , 0.2f );
          id: voice_assistant_leds
          effect: "Thinking"

  # Script executed when the voice assistant is thinking to a command
  # Fast anticlockwise spin of the LED ring.
  - id: control_leds_voice_assistant_replying_phase
    then:
      - light.turn_on:
          brightness: !lambda return max( id(led_ring).current_values.get_brightness() , 0.2f );
          id: voice_assistant_leds
          effect: "Replying"

  # Script executed when the voice assistant is in error
  # Fast Red Pulse
  - id: control_leds_voice_assistant_error_phase
    then:
      - light.turn_on:
          brightness: !lambda return min ( max( id(led_ring).current_values.get_brightness() , 0.2f ) + 0.1f , 1.0f );
          red: 1
          green: 0
          blue: 0
          id: voice_assistant_leds
          effect: "Error"

  # Script executed when the voice assistant is muted or silent
  # The LED next to the 2 microphones turn red / one red LED next to the speaker grill
  - id: control_leds_muted_or_silent
    then:
      - light.turn_on:
          brightness: !lambda return max( id(led_ring).current_values.get_brightness() , 0.2f );
          id: voice_assistant_leds
          effect: "Muted or Silent"

  # Script executed when the voice assistant is not ready
  - id: control_leds_voice_assistant_not_ready_phase
    then:
      - light.turn_on:
          brightness: 66%
          red: 1
          green: 0
          blue: 0
          id: voice_assistant_leds
          effect: "Twinkle"

  # Script executed when the dial is touched
  # A number of LEDs turn on indicating a visual representation of the volume of the media player entity.
  - id: control_leds_dial_touched
    then:
      - light.turn_on:
          brightness: !lambda return max( id(led_ring).current_values.get_brightness() , 0.2f );
          id: voice_assistant_leds
          effect: "Volume Display"

  # Script executed when the jack has just been unplugged
  # A ripple effect
  - id: control_leds_jack_unplugged_recently
    then:
      - light.turn_on:
          brightness: !lambda return max( id(led_ring).current_values.get_brightness() , 0.2f );
          id: voice_assistant_leds
          effect: "Jack Unplugged"

  # Script executed when the jack has just been plugged
  # A ripple effect
  - id: control_leds_jack_plugged_recently
    then:
      - light.turn_on:
          brightness: !lambda return max( id(led_ring).current_values.get_brightness() , 0.2f );
          id: voice_assistant_leds
          effect: "Jack Plugged"

  # Script executed when the center button is touched
  # The complete LED ring turns on
  - id: control_leds_center_button_touched
    then:
      - light.turn_on:
          brightness: !lambda return min ( max( id(led_ring).current_values.get_brightness() , 0.2f ) + 0.1f , 1.0f );
          id: voice_assistant_leds
          effect: "Center Button Touched"

  # Script executed when the timer is ringing, to control the LEDs
  # The LED ring blinks.
  - id: control_leds_timer_ringing
    then:
      - light.turn_on:
          brightness: !lambda return min ( max( id(led_ring).current_values.get_brightness() , 0.2f ) + 0.1f , 1.0f );
          id: voice_assistant_leds
          effect: "Timer Ring"

  # Script executed when the timer is ticking, to control the LEDs
  # The LEDs shows the remaining time as a fraction of the full ring.
  - id: control_leds_timer_ticking
    then:
      - light.turn_on:
          brightness: !lambda return max( id(led_ring).current_values.get_brightness() , 0.2f );
          id: voice_assistant_leds
          effect: "Timer tick"

  # Script executed when the volume is increased/decreased from the dial
  - id: control_volume
    mode: restart
    parameters:
      increase_volume: bool  # True: Increase volume / False: Decrease volume.
    then:
      - delay: 16ms
      - if:
          condition:
            lambda: return increase_volume;
          then:
            - media_player.volume_up:
          else:
            - media_player.volume_down:
      - script.execute: control_leds
      - delay: 1s
      - lambda: id(dial_touched) = false;
      - sensor.rotary_encoder.set_value:
          id: dial
          value: 0
      - script.execute: control_leds

  # Script executed when the hue is increased/decreased from the dial
  - id: control_hue
    mode: restart
    parameters:
      increase_hue: bool  # True: Increase hue / False: Decrease hue.
    then:
      - delay: 16ms
      - if:
          condition:
            lambda: return(abs(int(id(dial).state)) > 3 || id(color_changed));
          then:
            - lambda: |
                id(color_changed) = true;
                auto light_color = id(voice_assistant_leds).current_values;
                int hue = 0;
                float saturation = 0;
                float value = 0;
                rgb_to_hsv( light_color.get_red(),
                            light_color.get_green(),
                            light_color.get_blue(),
                            hue,
                            saturation,
                            value);
                if (increase_hue) {
                  hue = (hue + 10) % 360;
                } else {
                  hue = (hue + 350) % 360;
                }
                if (saturation < 0.05) {
                  saturation = 1;
                }
                float red = 0;
                float green = 0;
                float blue = 0;
                hsv_to_rgb( hue,
                            saturation,
                            value,
                            red,
                            green,
                            blue);
                id(voice_assistant_leds).make_call().set_rgb(red, green, blue).perform();
      - wait_until:
          binary_sensor.is_off: center_button
      - lambda: |
          id(dial_touched) = false;
          // now we "save" the new LED color/state to led_ring, maintaining its brightness and state
          auto led_ring_call = id(led_ring).make_call();
          auto va_leds_cv = id(voice_assistant_leds).current_values;
          led_ring_call.from_light_color_values(va_leds_cv);
          led_ring_call.set_brightness(id(led_ring).current_values.get_brightness());
          led_ring_call.set_state(id(led_ring).current_values.is_on());
          led_ring_call.perform();
      - sensor.rotary_encoder.set_value:
          id: dial
          value: 0
      - script.execute: control_leds
      - delay: 500ms
      - lambda: id(color_changed) = false;

  # Script executed when the timer is ringing, to playback sounds.
  - id: ring_timer
    then:
      - script.execute: enable_repeat_one
      - script.execute:
          id: play_sound
          priority: true
          sound_file: !lambda return id(timer_finished_sound);

  # Script executed when the timer is ringing, to repeat the timer finished sound.
  - id: enable_repeat_one
    then:
      # Turn on the repeat mode and pause for 500 ms between playlist items/repeats
      - lambda: |-
            id(external_media_player)
              ->make_call()
              .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_REPEAT_ONE)
              .set_announcement(true)
              .perform();
            id(external_media_player)->set_playlist_delay_ms(speaker::AudioPipelineType::ANNOUNCEMENT, 500);

  # Script execute when the timer is done ringing, to disable repeat mode.
  - id: disable_repeat
    then:
      # Turn off the repeat mode and pause for 0 ms between playlist items/repeats
      - lambda: |-
            id(external_media_player)
              ->make_call()
              .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_REPEAT_OFF)
              .set_announcement(true)
              .perform();
            id(external_media_player)->set_playlist_delay_ms(speaker::AudioPipelineType::ANNOUNCEMENT, 0);

  # Script executed when we want to play sounds on the device.
  - id: play_sound
    parameters:
      priority: bool
      sound_file: "audio::AudioFile*"
    then:
      - lambda: |-
          if (priority) {
            id(external_media_player)
              ->make_call()
              .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_STOP)
              .set_announcement(true)
              .perform();
          }
          if ( (id(external_media_player).state != media_player::MediaPlayerState::MEDIA_PLAYER_STATE_ANNOUNCING ) || priority) {
            id(external_media_player)
              ->play_file(sound_file, true, false);
          }

  # Scripts for timer functionality (replaced with USB communication to Mac app)
  - id: fetch_first_active_timer
    then:
      # Timer data will be handled by Mac app via USB
      - lambda: |
          // Timer functionality moved to Mac app
          ESP_LOGD("usb_timer", "Timer fetch requested - handled by Mac app");

  - id: check_if_timers_active
    then:
      # Timer checking will be handled by Mac app via USB
      - lambda: |
          // Timer checking functionality moved to Mac app
          ESP_LOGD("usb_timer", "Timer check requested - handled by Mac app");
          id(is_timer_active) = false;  // Default to false in USB mode

  # Script used activate the stop word if the TTS step is long.
  # Why is this wrapped on a script?
  #   Becasue we want to stop the sequence if the TTS step is faster than that.
  #   This allows us to prevent having the deactivation of the stop word before its own activation.
  - id: activate_stop_word_once
    then:
      - delay: 1s
      # Enable stop wake word
      - if:
          condition:
            switch.is_off: timer_ringing
          then:
            - micro_wake_word.enable_model: stop
            - wait_until:
                not:
                  media_player.is_announcing:
            - if:
                condition:
                  switch.is_off: timer_ringing
                then:
                  - micro_wake_word.disable_model: stop

  # Audio recording and streaming scripts for USB communication
  - id: start_audio_recording
    then:
      - lambda: |-
          ESP_LOGD("audio", "Starting audio recording for USB streaming");
          // Signal to USB communication component to start streaming audio
          printf("{\"type\":\"start_audio_recording\",\"timestamp\":%lu}\n", millis());
          fflush(stdout);
      # Enable audio recording loop
      - script.execute: audio_recording_loop

  - id: stop_audio_recording
    then:
      - lambda: |-
          ESP_LOGD("audio", "Stopping audio recording");
          // Signal to USB communication component to stop streaming audio
          printf("{\"type\":\"stop_audio_recording\",\"timestamp\":%lu}\n", millis());
          fflush(stdout);
      # Stop the recording loop
      - script.stop: audio_recording_loop

  - id: audio_recording_loop
    mode: restart
    then:
      - while:
          condition:
            lambda: |-
              // Continue recording while in waiting or listening phase
              return id(voice_assistant_phase) == ${voice_assist_waiting_for_command_phase_id} || 
                     id(voice_assistant_phase) == ${voice_assist_listening_for_command_phase_id};
          then:
            # Use the USB communication component's audio injection system
            - lambda: |-
                // Use the audio injection system to get real microphone data
                static std::vector<int16_t> audio_buffer;
                audio_buffer.clear();
                
                // Check if we have recent audio data from injection
                if (id(usb_comm_component).has_recent_audio_data()) {
                  // Get real audio data from the injection buffer
                  id(usb_comm_component).get_latest_audio_data(audio_buffer, 160);
                  
                  // Debug logging
                  static int audio_log_counter = 0;
                  if (++audio_log_counter >= 100) {
                    int max_val = 0;
                    for (auto sample : audio_buffer) {
                      if (abs(sample) > max_val) max_val = abs(sample);
                    }
                    ESP_LOGI("AUDIO_INJECT", "Got real audio data - max amplitude: %d", max_val);
                    audio_log_counter = 0;
                  }
                } else {
                  // No recent audio data - send silence
                  audio_buffer.resize(160, 0);
                  
                  static int silence_log_counter = 0;
                  if (++silence_log_counter >= 100) {
                    ESP_LOGW("AUDIO_INJECT", "No recent audio data available - sending silence");
                    silence_log_counter = 0;
                  }
                }
                
                // Send the audio data
                std::string audio_data = "{\"type\":\"audio_data\",\"samples\":[";
                for (int i = 0; i < audio_buffer.size(); i++) {
                  if (i > 0) audio_data += ",";
                  audio_data += std::to_string(audio_buffer[i]);
                }
                audio_data += "],\"timestamp\":" + std::to_string(millis()) + "}";
                
                printf("%s\n", audio_data.c_str());
                fflush(stdout);
            # 10ms delay for 16kHz sampling rate
            - delay: 10ms

  - id: play_received_audio
    parameters:
      audio_data: string
    then:
      - lambda: |-
          ESP_LOGD("audio", "Playing received audio data");
          // In a real implementation, this would parse the audio_data parameter
          // and feed it to the speaker. For now, we'll just play a confirmation sound.
      - script.execute:
          id: play_sound
          priority: true
          sound_file: !lambda return id(wake_word_triggered_sound);

  # Script to auto-return to idle after voice processing (like factory firmware)
  - id: auto_return_to_idle
    mode: restart
    then:
      - delay: 3s  # Give Swift app time to process the audio and respond
      - lambda: |-
          ESP_LOGD("auto_idle", "Auto-returning to idle phase after processing timeout");
          id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
          id(usb_comm_component).update_voice_phase(${voice_assist_idle_phase_id});
          // Send processing complete event to USB app
          printf("{\"type\":\"processing_complete\",\"timestamp\":%lu}\n", millis());
          fflush(stdout);

  # REAL Voice Activity Detection using micro_wake_word's audio processing
  - id: start_voice_detection
    mode: restart
    then:
      # Send VAD start
      - lambda: |-
          ESP_LOGD("vad", "Starting REAL voice detection using microphone data");
          printf("{\"type\":\"vad_start\",\"timestamp\":%lu}\n", millis());
          fflush(stdout);
      # Transition to listening phase
      - lambda: |-
          id(voice_assistant_phase) = ${voice_assist_listening_for_command_phase_id};
          id(usb_comm_component).update_voice_phase(${voice_assist_listening_for_command_phase_id});
          // Start monitoring voice activity
          id(voice_detection_active) = true;
          id(silence_samples) = 0;
          id(voice_detected) = false;
      - script.execute: control_leds

  - id: stop_voice_detection
    mode: restart
    then:
      - lambda: |-
          ESP_LOGD("vad", "Stopping voice detection - 2 seconds of silence detected");
          printf("{\"type\":\"vad_end\",\"timestamp\":%lu}\n", millis());
          fflush(stdout);
          id(voice_detection_active) = false;
      # Transition to thinking phase
      - lambda: |-
          id(voice_assistant_phase) = ${voice_assist_thinking_phase_id};
          id(usb_comm_component).update_voice_phase(${voice_assist_thinking_phase_id});
      - script.execute: control_leds
      # Stop audio recording
      - script.execute: stop_audio_recording
      # Start auto-return to idle script
      - script.execute: auto_return_to_idle

  # Microphone data injection script
  - id: inject_microphone_data
    mode: queued
    then:
      - lambda: |-
          // STOP THE INJECTION COMPLETELY AND DISABLE THE AUDIO RECORDING LOOP
          // Since we can't easily access real microphone data without breaking ESPHome,
          // let's modify the main audio recording loop to send REAL microphone data directly
          
          auto *usb_comm = id(usb_comm_component);
          if (usb_comm != nullptr) {
            // Clear any injected data to force fallback to main audio loop
            // This will make the main recording loop use its fallback synthetic audio
            // which we can then replace with real microphone access
            
            static int disable_counter = 0;
            if (++disable_counter >= 500) {
              ESP_LOGI("mic_inject", "Injection disabled - main audio loop should handle real microphone");
              disable_counter = 0;
            }
          }
          
          // DO NOT inject any data - let the main audio recording loop handle everything

i2s_audio:
  - id: i2s_output
    # i2s_output data pin is gpio10
    i2s_lrclk_pin:
      number: GPIO7
    i2s_bclk_pin:
      number: GPIO8

  - id: i2s_input
    # data line is GPIO15
    i2s_lrclk_pin:
      number: GPIO14
    i2s_bclk_pin:
      number: GPIO13

microphone:
  - platform: i2s_audio
    id: i2s_mics
    i2s_din_pin: GPIO15
    adc_type: external
    pdm: false
    sample_rate: 16000
    bits_per_sample: 32bit
    i2s_mode: secondary
    i2s_audio_id: i2s_input
    channel: stereo

speaker:
  # Hardware speaker output
  - platform: i2s_audio
    id: i2s_audio_speaker
    sample_rate: 48000
    i2s_mode: secondary
    i2s_dout_pin: GPIO10
    bits_per_sample: 32bit
    i2s_audio_id: i2s_output
    dac_type: external
    channel: stereo
    timeout: never
    buffer_duration: 100ms
    audio_dac: aic3204_dac

  # Virtual speakers to combine the announcement and media streams together into one output
  - platform: mixer
    id: mixing_speaker
    output_speaker: i2s_audio_speaker
    num_channels: 2
    source_speakers:
      - id: announcement_mixing_input
        timeout: never
      - id: media_mixing_input
        timeout: never

  # Vritual speakers to resample each pipelines' audio, if necessary, as the mixer speaker requires the same sample rate
  - platform: resampler
    id: announcement_resampling_speaker
    output_speaker: announcement_mixing_input
    sample_rate: 48000
    bits_per_sample: 16
  - platform: resampler
    id: media_resampling_speaker
    output_speaker: media_mixing_input
    sample_rate: 48000
    bits_per_sample: 16

media_player:
  - platform: speaker
    id: external_media_player
    name: Media Player
    internal: False
    volume_increment: 0.05
    volume_min: 0.4
    volume_max: 0.85
    announcement_pipeline:
      speaker: announcement_resampling_speaker
      format: FLAC     # FLAC is the least processor intensive codec
      num_channels: 1  # Stereo audio is unnecessary for announcements
      sample_rate: 48000
    media_pipeline:
      speaker: media_resampling_speaker
      format: FLAC     # FLAC is the least processor intensive codec
      num_channels: 2
      sample_rate: 48000
    on_mute:
      - script.execute: control_leds
    on_unmute:
      - script.execute: control_leds
    on_volume:
      - script.execute: control_leds
    on_announcement:
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 20
          duration: 0.0s
    on_state:
      if:
        condition:
          and:
            - switch.is_off: timer_ringing
            # USB mode - no voice assistant running check needed
            - lambda: return true;
            - not:
                media_player.is_announcing:
        then:
          - mixer_speaker.apply_ducking:
              id: media_mixing_input
              decibel_reduction: 0
              duration: 1.0s
    files:
      - id: center_button_press_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_press.flac
      - id: center_button_double_press_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_double_press.flac
      - id: center_button_triple_press_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_triple_press.flac
      - id: center_button_long_press_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_long_press.flac
      - id: factory_reset_initiated_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/factory_reset_initiated.mp3
      - id: factory_reset_cancelled_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/factory_reset_cancelled.mp3
      - id: factory_reset_confirmed_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/factory_reset_confirmed.mp3
      - id: jack_connected_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/jack_connected.flac
      - id: jack_disconnected_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/jack_disconnected.flac
      - id: mute_switch_on_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/mute_switch_on.flac
      - id: mute_switch_off_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/mute_switch_off.flac
      - id: timer_finished_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/timer_finished.flac
      - id: wake_word_triggered_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/wake_word_triggered.flac
      - id: easter_egg_tick_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/easter_egg_tick.mp3
      - id: easter_egg_tada_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/easter_egg_tada.mp3
      - id: error_cloud_expired
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/error_cloud_expired.mp3

voice_kit:
  i2c_id: internal_i2c
  reset_pin: GPIO4
  firmware:
    url: https://github.com/esphome/voice-kit-xmos-firmware/releases/download/v1.3.1/ffva_v1.3.1_upgrade.bin
    version: "1.3.1"
    md5: 964635c5bf125529dab14a2472a15401

external_components:
  - source:
      type: git
      url: https://github.com/esphome/home-assistant-voice-pe
      ref: dev
    components:
      - voice_kit
    refresh: 0s
  - source:
      type: local
      path: ./components
    components:
      - usb_communication

audio_dac:
  - platform: aic3204
    id: aic3204_dac
    i2c_id: internal_i2c

micro_wake_word:
  id: mww
  microphone:
    microphone: i2s_mics
    channels: 1
    gain_factor: 16  # Much higher gain to detect real speech
  stop_after_detection: false
  models:
    - model: https://github.com/kahrendt/microWakeWord/releases/download/okay_nabu_20241226.3/okay_nabu.json
      id: okay_nabu
    - model: hey_jarvis
      id: hey_jarvis
    - model: hey_mycroft
      id: hey_mycroft
    - model: https://github.com/kahrendt/microWakeWord/releases/download/stop/stop.json
      id: stop
      internal: true
  vad:
    probability_cutoff: 0.5
    sliding_window_size: 4
  on_wake_word_detected:
    - lambda: |-
        ESP_LOGD("wake_word", "Wake word detected");
        printf("{\"type\":\"debug\",\"message\":\"wake_word_detected\"}\n");
        fflush(stdout);
    # If the wake word is detected when the device is muted (Possible with the software mute switch): Do nothing
    - if:
        condition:
          switch.is_off: master_mute_switch
        then:
          # If a timer is ringing: Stop it, do not start the voice assistant (We can stop timer from voice!)
          - if:
              condition:
                switch.is_on: timer_ringing
              then:
                - switch.turn_off: timer_ringing
              # No voice assistant to stop in USB mode
              else:
                - if:
                    condition:
                      media_player.is_announcing:
                    then:
                      - media_player.stop:
                          announcement: true
                    # Start the voice assistant and play the wake sound, if enabled
                    else:
                      - if:
                          condition:
                            switch.is_on: wake_sound
                          then:
                            - script.execute:
                                id: play_sound
                                priority: true
                                sound_file: !lambda return id(wake_word_triggered_sound);
                            - delay: 300ms
                      # Set voice assistant phase for USB mode LED control
                      - lambda: |-
                          ESP_LOGD("wake_word", "Wake word detected, setting waiting for command phase");
                          id(voice_assistant_phase) = ${voice_assist_waiting_for_command_phase_id};
                          id(usb_comm_component).update_voice_phase(${voice_assist_waiting_for_command_phase_id});
                          // Send wake word detected event to USB app
                          printf("{\"type\":\"wake_word_detected\",\"timestamp\":%lu}\n", millis());
                          fflush(stdout);
                      - script.execute: control_leds
                      # Start audio recording for the Swift app
                      - script.execute: start_audio_recording
                      # Start REAL voice detection
                      - script.execute: start_voice_detection

select:
  - platform: template
    id: wake_word_sensitivity
    name: "Wake word sensitivity"
    optimistic: true
    initial_option: Slightly sensitive
    restore_value: true
    entity_category: config
    options:
      - Slightly sensitive
      - Moderately sensitive
      - Very sensitive
    on_value:
      # Sets specific wake word probabilities computed for each particular model
      # Note probability cutoffs are set as a quantized uint8 value, each comment has the corresponding floating point cutoff
      # False Accepts per Hour values are tested against all units and channels from the Dinner Party Corpus.
      # These cutoffs apply only to the specific models included in the firmware: okay_nabu@20241226.3, hey_jarvis@v2, hey_mycroft@v2
      lambda: |-
        if (x == "Slightly sensitive") {
          id(okay_nabu).set_probability_cutoff(217);    // 0.85 -> 0.000 FAPH on DipCo (Manifest's default)
          id(hey_jarvis).set_probability_cutoff(247);   // 0.97 -> 0.563 FAPH on DipCo (Manifest's default)
          id(hey_mycroft).set_probability_cutoff(253);  // 0.99 -> 0.567 FAPH on DipCo
        } else if (x == "Moderately sensitive") {
          id(okay_nabu).set_probability_cutoff(176);    // 0.69 -> 0.376 FAPH on DipCo
          id(hey_jarvis).set_probability_cutoff(235);   // 0.92 -> 0.939 FAPH on DipCo
          id(hey_mycroft).set_probability_cutoff(242);  // 0.95 -> 1.502 FAPH on DipCo (Manifest's default)
        } else if (x == "Very sensitive") {
          id(okay_nabu).set_probability_cutoff(143);    // 0.56 -> 0.751 FAPH on DipCo
          id(hey_jarvis).set_probability_cutoff(212);   // 0.83 -> 1.502 FAPH on DipCo
          id(hey_mycroft).set_probability_cutoff(237);  // 0.93 -> 1.878 FAPH on DipCo
        }

# Cannot use voice_assistant in USB-only mode (requires API/network connectivity)
# Will implement simple timeout-based VAD as fallback since we can't access real VAD

button:
  - platform: factory_reset
    id: factory_reset_button
    name: "Factory Reset"
    entity_category: diagnostic
    internal: true
  - platform: restart
    id: restart_button
    name: "Restart"
    entity_category: config
    disabled_by_default: true
    icon: "mdi:restart"

# USB Connection Monitor with heartbeat tracking
interval:
  - interval: 3s
    then:
      - lambda: |-
          static unsigned long last_heartbeat_seen = 0;
          static bool was_connected = false;
          unsigned long now = millis();
          
          // Track recent heartbeat activity by checking if we've seen recent messages
          // The USB component sends status updates every 1 second when active
          // We'll consider the connection active if we're past initial boot
          if (now > 20000) {  // Wait 20 seconds after boot
            // Simple heuristic: if we're running and past boot time, assume connected
            // until we receive an explicit disconnect message
            bool should_be_connected = true;  // Default to connected for USB mode
            
            if (should_be_connected != id(usb_connected)) {
              if (should_be_connected) {
                ESP_LOGD("usb_monitor", "USB connection established");
                id(usb_connected) = true;
                id(control_leds).execute();
              } else {
                ESP_LOGD("usb_monitor", "USB connection lost");
                id(usb_connected) = false;
                id(control_leds).execute();
              }
            }
          }
  # USB configuration sync interval
  - interval: 1s
    then:
      - lambda: |-
          // Check if the USB communication component has pending config changes
          static std::string last_applied_sensitivity = "";
          static int last_applied_voice_phase = 1;
          
          auto current_sensitivity = id(usb_comm_component).get_current_sensitivity();
          auto current_setting = id(wake_word_sensitivity).state;
          auto current_voice_phase = id(usb_comm_component).get_current_voice_phase();
          
          // Apply sensitivity changes
          if (current_sensitivity != last_applied_sensitivity && current_sensitivity != current_setting) {
            ESP_LOGD("usb_config", "Applying sensitivity change: %s", current_sensitivity.c_str());
            auto call = id(wake_word_sensitivity).make_call();
            call.set_option(current_sensitivity);
            call.perform();
            last_applied_sensitivity = current_sensitivity;
          }
          
          // Apply voice phase changes for LED control
          if (current_voice_phase != last_applied_voice_phase) {
            ESP_LOGD("usb_config", "Applying voice phase change: %d", current_voice_phase);
            id(voice_assistant_phase) = current_voice_phase;
            id(control_leds).execute();
            last_applied_voice_phase = current_voice_phase;
          }
  # Audio confirmation interval - play sound after audio recording stops
  - interval: 500ms
    then:
      - lambda: |-
          // Simple workaround: Play confirmation sound 2 seconds after recording stops
          static unsigned long last_recording_stop = 0;
          static bool played_confirmation = false;
          
          // Check if we're no longer in recording phases
          bool recording_active = (id(voice_assistant_phase) == ${voice_assist_waiting_for_command_phase_id} || 
                                  id(voice_assistant_phase) == ${voice_assist_listening_for_command_phase_id});
          
          // Debug: Log current phase every 5 seconds
          static unsigned long last_debug = 0;
          if (millis() - last_debug > 5000) {
            ESP_LOGD("usb_audio", "Current phase: %d, recording_active: %s, wake_sound: %s", 
                     id(voice_assistant_phase), recording_active ? "YES" : "NO", 
                     id(wake_sound).state ? "YES" : "NO");
            last_debug = millis();
          }
          
          if (!recording_active) {
            // Recording stopped
            if (last_recording_stop == 0) {
              last_recording_stop = millis();
              played_confirmation = false;
              ESP_LOGD("usb_audio", "Recording stopped (phase %d), will play confirmation in 2 seconds", id(voice_assistant_phase));
            }
            
            // Play confirmation sound 2 seconds after recording stops
            if (!played_confirmation && (millis() - last_recording_stop) > 2000) {
              if (id(wake_sound).state) {
                ESP_LOGD("usb_audio", "Playing audio confirmation sound NOW");
                id(play_sound).execute(true, id(center_button_press_sound));
                played_confirmation = true;
              } else {
                ESP_LOGD("usb_audio", "Wake sound disabled - skipping confirmation");
                played_confirmation = true;
              }
            }
          } else {
            // Recording is active, reset state
            if (last_recording_stop != 0) {
              ESP_LOGD("usb_audio", "Recording active again (phase %d), resetting timer", id(voice_assistant_phase));
            }
            last_recording_stop = 0;
            played_confirmation = false;
          }
  
  # USB Audio playback interval - check for received audio to play
  - interval: 100ms
    then:
      - lambda: |-
          // USB audio streaming is now handled directly in the component
          // The finish_audio_stream() method handles speaker streaming
  
  # REAL MICROPHONE DATA CALLBACK SETUP - This runs once to setup the data callback
  - interval: 1s
    startup_delay: 5s
    then:
      - lambda: |-
          static bool callback_setup = false;
          if (!callback_setup) {
            ESP_LOGI("MIC_SETUP", "Setting up REAL microphone data callback");
            
            auto* mic = id(i2s_mics);
            if (mic != nullptr) {
              // Add data callback to receive REAL audio data from the microphone
              mic->add_data_callback([](const std::vector<uint8_t> &data) {
                // This callback receives REAL audio data from the I2S microphone
                // Data format: 32-bit I2S samples that need conversion to 16-bit PCM
                
                if (data.empty()) return;
                
                // The microphone is configured as 32-bit STEREO, so convert properly
                const int32_t* samples_32 = reinterpret_cast<const int32_t*>(data.data());
                size_t sample_count_32 = data.size() / 4; // 4 bytes per 32-bit sample
                
                // Convert 32-bit I2S stereo samples to 16-bit mono PCM
                static std::vector<int16_t> converted_samples;
                converted_samples.clear();
                converted_samples.reserve(sample_count_32 / 2); // Stereo to mono conversion
                
                // Process stereo pairs: try right channel instead of left
                for (size_t i = 0; i < sample_count_32; i += 2) {
                  // ESP32 I2S microphone data format varies - try different approaches
                  // Use right channel (i+1) instead of left channel (i)
                  int32_t sample_32 = (i + 1 < sample_count_32) ? samples_32[i + 1] : samples_32[i];
                  int16_t sample_16;
                  
                  // Try the most common ESP32 I2S format: 24-bit data in upper 24 bits
                  if (abs(sample_32) > 0x800000) {
                    // Data appears to be in upper 24 bits
                    sample_16 = static_cast<int16_t>(sample_32 >> 16);
                  } else if (abs(sample_32) > 0x8000) {
                    // Data appears to be in middle 16 bits
                    sample_16 = static_cast<int16_t>(sample_32 >> 8);
                  } else {
                    // Data appears to be in lower 16 bits already
                    sample_16 = static_cast<int16_t>(sample_32);
                  }
                  
                  // Try inverting the signal in case it's phase-inverted and add slight amplification
                  int32_t amplified = -sample_16 * 2; // 2x gain for better clarity
                  
                  // Apply soft limiting instead of hard clipping
                  if (amplified > 16000) {
                    amplified = 16000 + (amplified - 16000) / 4; // Soft limit
                  } else if (amplified < -16000) {
                    amplified = -16000 + (amplified + 16000) / 4; // Soft limit
                  }
                  
                  // Final clamp to 16-bit range
                  if (amplified > INT16_MAX) amplified = INT16_MAX;
                  if (amplified < INT16_MIN) amplified = INT16_MIN;
                  
                  converted_samples.push_back(static_cast<int16_t>(amplified));
                }
                
                const int16_t* samples = converted_samples.data();
                size_t sample_count = converted_samples.size();
                
                // Only inject during recording phases
                if (id(voice_assistant_phase) == ${voice_assist_waiting_for_command_phase_id} || 
                    id(voice_assistant_phase) == ${voice_assist_listening_for_command_phase_id}) {
                  
                  // Inject REAL microphone data into USB communication
                  id(usb_comm_component).inject_audio_data(samples, sample_count);
                  
                  // Debug logging
                  static int callback_counter = 0;
                  if (++callback_counter >= 100) {
                    int max_val = 0;
                    for (size_t i = 0; i < sample_count; i++) {
                      if (abs(samples[i]) > max_val) max_val = abs(samples[i]);
                    }
                    ESP_LOGI("REAL_MIC", "REAL AUDIO: %zu mono samples converted from %zu stereo 32-bit samples, max amplitude: %d", 
                             sample_count, sample_count_32, max_val);
                    
                    // Debug first few samples and raw data
                    if (sample_count >= 5) {
                      ESP_LOGI("REAL_MIC", "First 5 converted mono samples: %d, %d, %d, %d, %d", 
                               samples[0], samples[1], samples[2], samples[3], samples[4]);
                      ESP_LOGI("REAL_MIC", "First 6 raw 32-bit stereo samples: 0x%08X, 0x%08X, 0x%08X, 0x%08X, 0x%08X, 0x%08X", 
                               samples_32[0], samples_32[1], samples_32[2], samples_32[3], samples_32[4], samples_32[5]);
                    }
                    callback_counter = 0;
                  }
                }
              });
              
              ESP_LOGI("MIC_SETUP", "REAL microphone data callback registered successfully");
              callback_setup = true;
            } else {
              ESP_LOGE("MIC_SETUP", "Microphone component not found!");
            }
          }
          // This interval can be used for monitoring or other tasks
          if (id(usb_comm_component).should_play_audio()) {
            ESP_LOGD("usb_audio", "USB audio stream completed");
            // Audio has already been streamed to speaker by finish_audio_stream()
          }
  
  # Microphone data injection interval - capture real microphone data
  - interval: 10ms
    then:
      - script.execute: inject_microphone_data
  
  # USB Control interval - handle unmute/volume requests from USB component
  - interval: 50ms
    then:
      - lambda: |-
          // Check if USB component has requested unmute
          if (id(usb_comm_component).is_unmute_requested()) {
            ESP_LOGI("usb_control", "Processing unmute request from USB");
            // Unmute the media player
            auto unmute_call = id(external_media_player).make_call();
            unmute_call.set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_UNMUTE);
            unmute_call.perform();
            // Also ensure hardware isn't muted
            if (id(hardware_mute_switch).state) {
              ESP_LOGW("usb_control", "Hardware mute switch is ON - cannot unmute via software");
            } else {
              id(master_mute_switch).turn_off();
            }
          }
          
          // Check if USB component has requested volume change
          if (id(usb_comm_component).is_volume_change_requested()) {
            float requested_volume = id(usb_comm_component).get_requested_volume();
            ESP_LOGI("usb_control", "Processing volume change request: %f", requested_volume);
            // Set the volume on the media player
            auto volume_call = id(external_media_player).make_call();
            volume_call.set_volume(requested_volume);
            volume_call.perform();
          }
          
          // Check if USB component has requested tone playback
          if (id(usb_comm_component).is_tone_playback_requested()) {
            ESP_LOGI("usb_control", "Processing tone playbook request using factory firmware method");
            // Use the exact same script and sound file as the factory firmware
            id(play_sound).execute(true, id(center_button_press_sound));
          }

  # REAL Voice Detection - monitors microphone activity every 100ms
  - interval: 100ms
    then:
      - lambda: |-
          // Only run when voice detection is active
          if (!id(voice_detection_active)) {
            return;
          }
          
          // Use the ACTUAL VAD API method from micro_wake_word
          auto mww_component = id(mww);
          if (mww_component == nullptr) {
            return;
          }
          
          // Get REAL voice activity detection state using the proper API
          bool voice_activity_detected = mww_component->get_vad_state();
          
          if (voice_activity_detected) {
            // Voice detected - reset silence counter
            id(silence_samples) = 0;
            if (!id(voice_detected)) {
              ESP_LOGD("vad", "REAL voice activity detected via VAD API");
              id(voice_detected) = true;
            }
          } else {
            // No voice detected - increment silence counter
            id(silence_samples) = id(silence_samples) + 1;
          }
          
          // Stop after 20 silence samples (2 seconds) but only after voice was detected first
          if (id(voice_detected) && id(silence_samples) >= 20) {
            ESP_LOGD("vad", "Voice ended - 2 seconds of REAL silence after speech");
            id(stop_voice_detection).execute();
          }
          
          // Debug logging
          static unsigned long last_debug = 0;
          unsigned long now = millis();
          if (now - last_debug > 2000) {
            ESP_LOGD("vad", "REAL VAD: vad_state=%s, voice_detected=%s, silence=%d", 
                     voice_activity_detected ? "YES" : "NO", id(voice_detected) ? "YES" : "NO", id(silence_samples));
            last_debug = now;
          }




debug:
  update_interval: 5s

# USB Communication Component - Uses USB Serial/JTAG via printf/scanf
usb_communication:
  id: usb_comm_component

# Configuration sync interval added to existing interval section above
